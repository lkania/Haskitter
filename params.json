{
  "name": "Haskitter",
  "tagline": "A Twitter API written in Haskell",
  "body": "Cada ruta llama a su correspondiente handler, el cual está compuesto por una concatenación de funciones. A continuación vamos a explicar que retornan las distintas rutas y cómo hacen uso de dichos handlers.\r\n\r\nÉstas son todas las rutas que tiene la API:\r\n\r\n    - /posts\r\n    - /postsWithUser\r\n    - /users\r\n    - /user/:id\r\n    - /feed/:id\r\n    - /post\r\n    - /follow\r\n    - /signup\r\n    - /user/:id\r\n\r\n#### /posts\r\n\r\nÉste endpoint retorna todos los posts de la base de datos.\r\n\r\n```haskell\r\n\"/posts\" , method GET $ headersHandler $ runHandler $ genericHandler $ postsIndexHandler\r\n```\r\n\r\n___\r\n\r\nSe comienza llamando a la función `postsIndexHandler`, la cual retorna un valor del tipo `ExceptT Error AppHandler [Post]`.\r\n\r\n```haskell\r\npostsIndexHandler :: ExceptT Error AppHandler [Post]\r\npostsIndexHandler = getPosts\r\n```\r\n\r\n`postsIndexHandler` no recibe ningún parámtero de entrada, y llama a la función `getPosts`.\r\n\r\n```haskell\r\ngetPosts :: ExceptT Error AppHandler [Post]\r\ngetPosts = lift $ with pg $ query_ \"SELECT message,user_id FROM posts\"\r\n```\r\n\r\nLa función `getPosts` realiza una query para obtener todos los posts de la base de datos. Utiliza la Snaplet de PostgreSql, y retorna un array de posts como un valor monádico de `AppHandler`, siendo el tipo retornado `AppHandler [Post]` haciendo un lift de dicha mónada a `ExceptT Error AppHandler [Post]`.\r\n\r\n___\r\n\r\n```haskell\r\ngenericHandler $ handler\r\n```\r\n\r\n`genericHandler` es una función que recibe un handler (mónada del tipo `ExceptT Error AppHandler a`) y retorna un handler (mónada del tipo `ExceptT Error AppHandler ()`). \r\n\r\n```haskell\r\ngenericHandler :: ToJSON a => ExceptT Error AppHandler a -> ExceptT Error AppHandler ()\r\ngenericHandler handler = do\r\n  obj <- handler\r\n  lift $ writeLBS . encode $ obj\r\n```\r\n\r\n`genericHandler` en su declaración de tipos obliga a que el tipo de `a` haya instanciado `ToJSON` debido a que es aquel valor el cual va a ser el body de la respuesta HTTP.\r\n\r\nEl handler es una mónada que tiene valor monádico `a`. Éste valor a se pasa por parámetro a la función `(\\obj -> lift $ writeLBS . encode $ obj)` mediante el operador `(>>=)`.  Al realizar `writeLBS . encode $ obj` estamos codificando en json el objeto (sabemos que el valor monádico ha instanciado `ToJSON`) y lo escribimos en el body de la HTTP response mediante `writeLBS`, ésto tiene tipo `AppHandler ()`, el cual lifteamos para retornar `ExceptT Error AppHandler ()`.\r\n\r\n___\r\n\r\n```haskell\r\nrunHandler $ genericHandler $ handler\r\n```\r\n\r\n`genericHandler` se concatena con `runHandler`.\r\n\r\n`runHandler` es una función que recibe un handler (mónada del tipo `ExceptT Error AppHandler ()`) y retorna un handler (mónada del tipo `AppHandler ()`).\r\n\r\n```haskell\r\nrunHandler :: ExceptT Error AppHandler () -> AppHandler ()\r\nrunHandler handler = do\r\n  runExceptT handler\r\n  return ()\r\n```\r\n\r\n`runHandler` puede ser reescrita como:\r\n\r\n```haskell\r\nrunHandler :: ExceptT Error AppHandler () -> AppHandler ()\r\nrunHandler handler = (runExceptT handler) >>= (\\a -> return ())\r\n```\r\n\r\nEl parámetro `handler` tiene un tipo `ExceptT Error AppHandler ()`, pero queremos retornar `AppHandler ()`, por lo que realizamos la función `runExcpetT`, la cual nos devuelve el valor monádico de `ExceptT Error AppHandler ()` que es la mónada `AppHandler ()`. Éste valor se pasa mediante binding a la función `(\\a -> return ())`, la cual ignora el parámetro y retorna `AppHandler ()`.\r\n\r\nNosotros no podríamos haber hecho `(handler) >>= (\\a -> return ())`, pues el tipo de `>>=` es `:: m a -> (a -> m b) -> m b`, por lo tanto ya que handler es `ExceptT Error AppHandler a`, se debería retornar `ExceptT Error AppHandler b`, el cual no es el tipo que necesitamos.\r\n\r\n___\r\n\r\n```haskell\r\nheadersHandler $ runHandler $ genericHandler $ handler\r\n```\r\n\r\n`handler` se concatena con `genericHandler` que se concatena con `runHandler` que se concatena con `headersHandler`.\r\n\r\n`headersHandler` es una función que recibe un handler (mónada del tipo `AppHandler ()`) y retorna un handler (mónada del tipo `AppHandler ()`).\r\n\r\n```haskell\r\nheadersHandler :: AppHandler () -> AppHandler ()\r\nheadersHandler appHandler = do\r\n  modifyResponse $ setHeader \"Content-Type\" \"application/json\"\r\n  appHandler\r\n```\r\n\r\nÉsta función puede ser reescrita como:\r\n\r\n```haskell\r\nheadersHandler :: AppHandler () -> AppHandler ()\r\nheadersHandler handler = (modifyResponse $ setHeader \"Content-Type\" \"application/json\") >>= (\\a -> handler)\r\n```\r\n\r\n`(modifyResponse $ setHeader \"Content-Type\" \"application/json\")` es una función que modifica el contexto modificando el HTTP response seteando el header “Content-Type”, especificando que la respuesta va a contener el formato json, dado a que es una API, y retornando `AppHandler ()`. Mediante el binding éste valor es pasado como parámetro a `(\\a -> appHandler)` que lo ignora y retorna handler (de tipo `AppHandler ()`).\r\n\r\n___\r\n\r\n```haskell\r\nmethod GET $ headersHandler $ runHandler $ genericHandler $ handler\r\n```\r\n\r\n`handler` se concatena con `genericHandler` que se concatena con `runHandler` que se concatena con `headersHandler`, que se pasa como segundo parámetro a la función `method`.\r\n\r\n```haskell\r\nmethod :: MonadSnap m => Method -> m a -> m a\r\n```\r\n\r\n`method` pertence al modulo `Snap.Core`, el cual recibe una función de tipo `Method` por primer parámetro y una `MonadSnap` por segundo parámetro. `method` ejecuta la `MonadSnap` si el método de la request HTTP coincide con el método pasado como argumento, en éste caso el método GET. Ésta información la consigue accediendo al contexto que nos provee `Snap`, que provee toda la información sobre el HTTP Request y HTTP Response.\r\n\r\nPodemos ver por el tipo de `method` que nuestro handler (`headersHandler $ runHandler $ genericHandler $ handler`) es instancia de `MonadSnap`. `MonadSnap` es el equivalente de `MonadIO` para `IO`, por lo que nos permite extender la funcionalidad accediendo a la monada `Snap` cuando queramos.\r\n\r\n```haskell\r\nclass (Monad m) => MonadSnap m where\r\nliftSnap :: Snap a -> m a\r\n```\r\n\r\nAhora bien, ¿cómo estamos accediendo a `Snap` en el handler? Uno esperaría que obtengamos la monada `Snap`, modifiquemos el contexto a traves de ella y luego realizemos `liftSnap` para obtener la `MonadSnap` de nuevo. Esto no se ve en en handler debido a que utilizamos la función `writeLBS`. \r\n\r\n```haskell\r\nwriteLBS :: MonadSnap m => ByteString -> m ()\r\n```\r\n\r\n`writeLBS` oculta este comportamiento y escribe el string en el body de la HTTP Response. \r\n\r\nTodo handler se agrega en `routes` de la siguiente manera:\r\n\r\n```haskell\r\nroutes :: [(BS.ByteString, AppHandler ())]\r\nroutes = [\r\n        ...\r\n        (\"/endpoint\", method METHOD $ headersHandler $ runHandler $ genericHandler $ handler),\r\n        ...\r\n      ]\r\n```\r\n\r\nTodo handler está en el array que es retornado por la función constante `routes`.\r\n\r\n#### /postsWithUser\r\n\r\nÉste endpoint retorna todos los posts de la base de datos con el usuario que los creó asociado.\r\n\r\n```haskell\r\n\"/postsWithUser\", method GET $ headersHandler $ runHandler $ genericHandler $ postsWitUserIndexHandler\r\n```\r\n\r\n___\r\n\r\nSe comienza llamando a la función `postsWithUserIndexHandler`, la cual no recibe ningún parámtero de entrada y retorna un valor del tipo `ExceptT Error AppHandler [PostWithUser]`. Ésta función lo único que hace es llamar a la función `getPostsWithUser`.\r\n\r\n```haskell\r\npostsWitUserIndexHandler :: ExceptT Error AppHandler [PostWithUser]\r\npostsWitUserIndexHandler = getPostsWithUser\r\n```\r\n\r\n`getPostsWithUser` es una función que no recibe parámetro de entrada y retorna `ExceptT Error AppHandler [PostWithUser]`. \r\n\r\n```haskell\r\ngetPostsWithUser :: ExceptT Error AppHandler [PostWithUser]\r\ngetPostsWithUser = do\r\n  posts <- getPosts\r\n  concatAppHandlerList $ postsToPostsWithUser posts\r\n```\r\n\r\nLa función `getPostsWithUser` la podemos reescribir de la siguiente forma:\r\n\r\n```haskell\r\ngetPostsWithUser :: ExceptT Error AppHandler [PostWithUser]\r\ngetPostsWithUser = getPosts >>= (\\posts -> concatAppHandlerList $ postsToPostsWithUser posts)\r\n```\r\n\r\n`getPosts` es una función que ya se explicó previamente, la cual retorna `ExceptT Error AppHandler [Post]`. Luego el operador bind (>>=) toma la monada retornada por la función `ExceptT Error AppHandler [Post]` y le pasa el valor monádico `[Post]` a función (\\posts -> concatAppHandlerList $ postsToPostsWithUser posts).\r\n\r\n`postsToPostsWithUser` es una función que recibe un array de `Post` y retorna `[ExceptT Error AppHandler PostWithUser]` (un array de elementos del tipo `ExceptT Error AppHandler PostWithUser`).\r\n\r\n```haskell\r\npostsToPostsWithUser :: [Post] -> [ExceptT Error AppHandler PostWithUser]\r\npostsToPostsWithUser posts = map postToPostWithUser posts\r\n```\r\n\r\n`postsToPostsWithUser` lo que hace es mapear el array de posts con la función `postToPostWithUser` (mediante la función `map`).\r\n\r\n`postToPostWithUser` es una función que recibe `Post` y retorna `ExceptT Error AppHandler PostWithUser`.\r\n\r\n```haskell\r\npostToPostWithUser :: Post -> ExceptT Error AppHandler PostWithUser\r\npostToPostWithUser post = do\r\n  user <- getUserById $ show $ user_id post\r\n  lift $ return $ createPostWithUser post user\r\n```\r\n\r\nA ésta función la podemos reescribir de la siguiente manera:\r\n\r\n```haskell\r\npostToPostWithUser :: Post -> ExceptT Error AppHandler PostWithUser\r\npostToPostWithUser post = (getUserById $ show $ user_id post) >>= (\\user -> lift $ return $ createPostWithUser post user)\r\n```\r\n\r\n`(getUserById $ show $ user_id post)` es una función que primero con `(user_id post)` obtiene el `user_id` del post en cuestión, luego con la función `show` se convierte el `user_id` de `Int` a `String`, y por último se le envía dicho `String` como argumento a la función `getuserById`, la cual retorna `ExceptT Error AppHandler User`. Mediante el binding, éste valor se le pasa a la función `(\\user -> lift $ return $ createPostWithUser post user)`, la cual utiliza el valor monádico de aquél valor, siendo éste el `User`.\r\n\r\nLa función `(\\user -> lift $ return $ createPostWithUser post user)` lo que hace es llamar con el `post` recibido por argumento y el `user` ya mencionado a la función `createPostWithUser`, la cual retorna `PostWithUser`.\r\n\r\n```haskell\r\ncreatePostWithUser :: Post -> User -> PostWithUser\r\ncreatePostWithUser post user = PostWithUser post user\r\n```\r\n\r\nAhora sí, volviendo a la función `getPostsWithUser`, se le pasa como argumento el resultado de `postsToPostsWithUser posts` (siendo éste `[ExceptT Error AppHandler PostWithUser]`) a la función `concatAppHandlerList`, que se encarga de pasar a `ExceptT Error AppHandler [PostWithUser]`.\r\n\r\n___\r\n\r\nLuego sigue la concatenación de handlers como ya se explicó previamente.\r\n\r\n#### /users\r\n\r\nÉste endpoint retorna todos los usuarios de la base de datos.\r\n\r\n```haskell\r\n\"/users\", method GET $ headersHandler $ runHandler $ genericHandler $ usersIndexHandler\r\n```\r\n\r\nSe comienza llamando a la función `usersIndexHandler`, la cual no recibe ningún parámtero de entrada y retorna un valor del tipo `ExceptT Error AppHandler [User]`. Ésta función lo único que hace es llamar a la función `getUsers`.\r\n\r\n```haskell\r\nusersIndexHandler :: ExceptT Error AppHandler [User]\r\nusersIndexHandler = getUsers\r\n```\r\n\r\n`getUsers` es una función que no recibe argumentos y retorna `ExceptT Error AppHandler [User]`.\r\n\r\n```haskell\r\ngetUsers :: ExceptT Error AppHandler [User]\r\ngetUsers = lift $ with pg $ query_ \"SELECT id,email,\\\"name\\\",password FROM users\"\r\n```\r\n\r\nSimilar a la función `getPosts`, la función `getUsers` realiza una query para obtener todos los usuarios de la base de datos. Utiliza la Snaplet de PostgreSql, y retorna un array de usuarios como un valor monádico de `AppHandler`, siendo el tipo retornado `AppHandler [User]` haciendo un lift de dicha mónada a `ExceptT Error AppHandler [User]`.\r\n\r\n___\r\n\r\nLuego sigue la concatenación de handlers como ya se explicó previamente.\r\n\r\n#### /user/:id\r\n\r\nÉste endpoint retorna la información del usuario con dicho `:id`. En caso de \r\n\r\n```haskell\r\n\"/user/:id\", method GET $ headersHandler $ runHandler $ genericHandler $ catchHandler $ userIdHandler $ userHandler\r\n```\r\n\r\n___\r\n\r\nSe comienza llamando a la función `userHandler`, la cual recibe como argumento `User` y retorna `ExceptT Error AppHandler User`.\r\n\r\n```haskell\r\nuserHandler :: User -> ExceptT Error AppHandler User\r\nuserHandler user = lift $ return user\r\n```\r\n\r\nLa función `userHandler` lo que hace es poner en el context `AppHanlder` al tipo `User`, quedando `AppHandler User`, y finaliza haciendo un lift de dicha mónada a `ExceptT Error AppHandler User`.\r\n\r\n___\r\n\r\n```haskell\r\nuserIdHandler $ handler\r\n```\r\n\r\n`userIdHandler` es una función que recibe una función del tipo `(User -> ExceptT Error AppHandler a)` y retorna un handler (mónada del tipo `ExceptT Error AppHandler a`).\r\n\r\n```haskell\r\nuserIdHandler :: (User -> ExceptT Error AppHandler a) -> ExceptT Error AppHandler a\r\nuserIdHandler handler = do\r\n  user_id <- lift $ getParam \"id\"\r\n  user <- maybe (throwE NullId) (\\user_id -> getUserById $ (byteStringToString user_id)) user_id\r\n  handler user\r\n```\r\n\r\nA ésta función la podemos reescribir de la siguiente manera:\r\n\r\n```haskell\r\nuserIdHandler :: (User -> ExceptT Error AppHandler a) -> ExceptT Error AppHandler a\r\nuserIdHandler handler = (lift $ getParam \"id\") >>= (\\user_id -> (maybe (throwE NullId) (\\user_id -> getUserById $ (byteStringToString user_id)) user_id >>= (\\user -> handler user)))\r\n```\r\n\r\nLa función `(lift $ getParam \"id\")` lo que hace es conseguir el parámetro `id` proveniente de la request mediante la función `getParam`, la cual retorna `AppHandler (Maybe ByteString)` y luego le hace un lift a `Except Error AppHandler (Maybe ByteString)`. Por medio del binding se le pasa el valor monádico a la función `(\\user_id -> (maybe (throwE NullId) (\\user_id -> getUserById $ (byteStringToString user_id)) user_id >>= (\\user -> handler user)))`. Comienza con la función `(maybe (throwE NullId) (\\user_id -> getUserById $ (byteStringToString user_id)) user_id`, que con la función `maybe`, en caso de que `user_id` sea `Nothing` retorna el error `NullId`, pero si `user_id` es `Just ByteString` entonces le pasa como argumento `user_id` a la función `(\\user_id -> getUserById $ (byteStringToString user_id))`, la cual convierte el `ByteString` de `user_id` a `String` para que lo reciba como argumento la función `getUserById`, la cual retorna `ExceptT Error AppHandler User`. Luego, mediante el operador bind la función `(\\user -> handler user)` recibe como argumento el valor monádico, siendo el mismo del tipo `User` y llama a la función `handler` con dicho `user`.\r\n\r\n___\r\n\r\n```haskell\r\ncatchHandler $ handler\r\n```\r\n\r\n`catchHandler` es una función que recibe como argumento `ExceptT Error AppHandler a` y retorna `ExceptT Error AppHandler a`.\r\n\r\n```haskell\r\ncatchHandler :: ExceptT Error AppHandler a -> ExceptT Error AppHandler a\r\ncatchHandler handler = handler `catchE` printError\r\n```\r\n\r\n`catchHandler` hace uso de la función `catchE` llamada de forma infija.\r\n\r\n`catchE` es una función que recibe como argumento un handler del tipo `ExceptT e m a`, una función del tipo `(e -> ExceptT c m a)` y retorna `ExceptT c m a`.\r\n\r\n```haskell\r\ncatchE :: Monad m => ExceptT e m a -> (e -> ExceptT c m a) -> ExceptT c m a\r\ncatchE handler errorHandler = ExceptT $ do\r\n  x <- runExceptT handler\r\n  case x of\r\n    Left failure  -> runExceptT (errorHandler failure)\r\n    Right success -> return (Right success)\r\n```\r\n\r\nÉsta función la podemos reescribir de la siguiente manera:\r\n\r\n```haskell\r\ncatchE :: Monad m => ExceptT e m a -> (e -> ExceptT c m a) -> ExceptT c m a\r\ncatchE handler errorHandler = ExceptT $ (runExceptT handler >>= (\\x -> case x of\r\n    Left failure  -> runExceptT (errorHandler failure)\r\n    Right success -> return (Right success)))\r\n```\r\n\r\nLa función\r\n\r\n```haskell\r\n(runExceptT handler >>= (\\x -> case x of\r\n    Left failure  -> runExceptT (errorHandler failure)\r\n    Right success -> return (Right success)))\r\n```\r\n\r\ncomienza con `runExceptT handler`, haciendo que del tipo `ExceptT e m a` pasemos a tener `m a`, en nuestro caso, pasamos del tipo `ExceptT Error AppHandler a` al tipo `AppHandler a`. Luego, ésto se pasa como argumento mediante el operador bind a la función\r\n\r\n```haskell\r\n(\\x -> case x of\r\n    Left failure  -> runExceptT (errorHandler failure)\r\n    Right success -> return (Right success))\r\n```\r\n\r\nÉsta función analiza el valor de `x`, y en caso de que sea `Left` se llama a la función `runExceptT (errorHandler failure)`, la cual le pasa como argumento el error (de tipo `Error`) a la función `errorHandler` (que recordemos que tenía el tipo `e -> ExceptT c m a`, siendo nuestro caso `Error -> ExceptT Error AppHandler a`), y luego se le pasa como argumento a la función `runExceptT` el retorno de la función `errorHandler` (siendo del tipo `ExceptT Error AppHandler a`), pasando al tipo `AppHandler a`. En caso de que sea `Right`\r\n\r\n___\r\n### Inicialización del servidor\r\n\r\nEl punto de entrada al programa es la función main, que tiene por tipo la monada IO.\r\n\r\n```haskell\r\nmain :: IO ()\r\nmain = do\r\n  (_, site, _) <- runSnaplet Nothing hashkitterInit\r\n  quickHttpServe site\r\n```\r\n\r\nLa misma puede ser reescrita como\r\n\r\n```haskell\r\nmain :: IO ()\r\nmain = runSnaplet Nothing haskitterInit (\\_ site _ -> quickHttpServe site)\r\n```\r\nLa función ejecutar `runSnaplet`\r\n\r\n```haskell\r\nrunSnaplet :: Maybe String -> SnapletInit b b -> IO (Text, Snap (), IO ())\r\n```\r\n\r\nRecibe un `Maybe String`, y un inicializador de `Snaplet` (`SnapletInit`). el string indica cuales son los nombres de los archivos de configuración tuilizados por cada Snaplet y en caso de recibir Nothing se utiliza `Just \"devel\"`. `runSnap` retorna una monada IO cuyos valores monádicos son\r\n- `Text` la concatenación de todos los logs durante la inicialización\r\n- `Snap ()` el handler de `Snap` que ha sido extendido por nuestros handlers de tipo `MonadSnap`\r\n- `IO ()` una acción de limpieza en ante el shutdown de la aplicación\r\n\r\nLuego el handler snap es pasado como parametro mediante el operador bind `>>=` a la función `(\\_ handler _ -> quickHttpServe handler)` que comienza el servidor HTTP utilizando el handler pasado por parametro. Los parametros para la configuración del servidor son obtenidos por la linea de comandos.\r\n\r\n```Haskell\r\nquickHttpServe :: Snap () -> IO ()\r\n```\r\n\r\nSnapletInit `quickHttpServe` no retorna nunca. Si se quiere apagar el servidor se debe matar el thread que lo corre.\r\n\r\n`haskitterInit` es la función pasada como segundo parametro a `runSnaplet`. `haskitterInit` no recibe ningun parametro y retorna `SnapletInit Haskitter Haskitter`. Por otro lado el tipo `SnapletInit b v` se utiliza para obtener garantias en tiempo de compliación de que la `Snaplet` fue creada utilizando `makeSnaplet`, `nestSnaplet` o `embedSnaplet`.\r\n\r\n```Haskell\r\nhaskitterInit :: SnapletInit Haskitter Haskitter\r\nhaskitterInit = makeSnaplet \"haskitter\" \"A simple twitter api written in Haskell\" Nothing $ do\r\n  p <- nestSnaplet \"pg\" pg pgsInit\r\n  addRoutes routes\r\n  return $ Haskitter { _pg = p}\r\n```\r\n\r\n`haskitterInit` se puede rescribir cómo\r\n\r\n```Haskell\r\nhaskitterInit :: SnapletInit Haskitter Haskitter\r\nhaskitterInit = makeSnaplet \"haskitter\" \"A simple twitter api written in Haskell\" Nothing (nestSnaplet \"pg\" pg pgsInit >>= (\\p -> addRoutes routes >> return $ Haskitter { _pg = p}))  \r\n```\r\n\r\n`haskitterInit` ejecuta `makeSnaplet` que recibe\r\n\r\n- `Text` un id para identificar al `Snaplet`  \r\n- `Text` una descripción del `Snaplet`\r\n- `Maybe (IO FilePath)` el path al directorio root de para la `Snaplet`\r\n    + En nuestro caso utilizamos `Nothing`, por lo que la `Snaplet` no copiará los archivos que genera automáticamente a ese directorio.\r\n- `Initializer b v v` el inicializador de la `Snaplet`.\r\n\r\n```Haskell\r\nmakeSnaplet :: Text -> Text -> -> Maybe (IO FilePath) -> Initializer b v v -> SnapletInit b v\r\n```\r\n\r\nEl inicializador de la `Snaplet` se obtiene como retorno de la función `nestSnaplet \"pg\" pg pgsInit >>= (\\p -> addRoutes routes >> return $ Haskitter { _pg = p})`. Luego makeSnaplet toma el `Initializer b v v` como parametro y retorna un `SnapInit Haskitter Haskitter`.\r\n\r\nAnalizemos la función `nestSnaplet \"pg\" pg pgsInit >>= (\\p -> addRoutes routes >> return $ Haskitter { _pg = p})` que retorna el `Initializer b v v` en detalle.\r\n\r\n```Haskell\r\nnestSnapletSource :: ByteString -> SnapletLens v v1 -> SnapletInit b v1 -> Initializer b v (Snaplet v1)\r\n```\r\n\r\n`nestSnapletSource` recibe  \r\n- `ByteString` una url que simboloza la ruta de la `Snaplet`\r\n- `SnapletLens` el lens que identifca a la `Snaplet`\r\n- `SnapInit` la función inicializadora uan `Snaplet`\r\n\r\n`nestSnapletSource` ejecuta el incializar y retorna la `Snaplet` inicializada. Al usar `nestSnapletSource` permitimos que la `Snaplet` anidada tenga acceso al estado base de la `Snaplet` actual. Por lo tanto en la función `nestSnaplet \"pg\" pg pgsInit` estas permitiendo que la `Snaplet` `pg` tenga acceso al estado base de la `Snaplet` `Snap`.\r\n\r\nEl valor monadico de la `Snaplet` (`Monad`) inicializada retornada por `nestSnaplet \"pg\" pg pgsInit` es recibida por parametro por la función  `(\\p -> addRoutes routes >> return $ Haskitter { _pg = p})` por el operador bind `>>=`.\r\n\r\n```Haskell\r\naddRoutes :: [(ByteString, Handler b v ())] -> Initializer b v ()\r\n```\r\n\r\n`addRoutes` agrega routeo al handler actual, y se mergea con el ruteo principal. Como el ruteo principal esta definido como \"/\", si se ejecuta `addRoutes :: [(\"/handler\", handler)]` el ruteo de `handler` será \"/handler\".  \r\n\r\nEl inicializador (`Monad`) retornado por `addRoutes` es pasado por parametro a la función `return $ Haskitter { _pg = p})`, que accede a p del contexto de la `Monad` e inicializa la `Snaplet` `Haskitter`, retornado un `Initializer`. Este `Initializer` es utilizado por makeSnaplet para retonar un `SnapletInit` para inicializar la `Snaplet`, que será el servidor.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}